# Minishell

## Funciones

<details>
<summary><strong>üì• Entrada y Lectura de Comandos</strong></summary>

<br>

| Funci√≥n                         | Descripci√≥n                                                                                             | Uso com√∫n                                                         | Uso con c√≥digo                                                   |
|----------------------------------|---------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|------------------------------------------------------------------|
| `readline(prompt)`              | Muestra el prompt y lee una l√≠nea de entrada del usuario. Devuelve un puntero a la l√≠nea le√≠da.         | Leer comandos del usuario con edici√≥n de l√≠nea                    | `char *s = readline("mini$ ");`                                 |
| `add_history(line)`             | A√±ade la l√≠nea al historial de comandos. √ötil para usar las flechas ‚Üë y ‚Üì.                              | Guardar comandos ejecutados para navegaci√≥n en el historial       | `if (*s) add_history(s);`                                       |
| `rl_clear_history()`            | Limpia el historial de readline liberando memoria.                                                      | Limpiar historial al salir del programa                           | `rl_clear_history();`                                           |
| `rl_on_new_line()`              | Notifica a readline que comienza una nueva l√≠nea. √ötil al manejar se√±ales.                              | Preparar readline tras una interrupci√≥n con Ctrl+C                | `rl_on_new_line();`                                             |
| `rl_replace_line(text, undo)`  | Reemplaza la l√≠nea actual por `text`. `undo` borra el historial de deshacer si es 1.                    | Borrar o reemplazar el texto actual en la l√≠nea de entrada        | `rl_replace_line("", 0);`                                       |
| `rl_redisplay()`                | Redibuja el prompt y la l√≠nea actual.                                                                   | Refrescar el prompt en pantalla tras una se√±al                    | `rl_redisplay();`                                               |
| `isatty(fd)`                    | Devuelve 1 si el descriptor es un terminal, 0 si no.                                                    | Comprobar si la entrada es interactiva                            | `if (isatty(STDIN_FILENO))`                                     |
| `ttyname(fd)`                   | Devuelve el nombre del terminal asociado con el descriptor.                                             | Obtener el nombre del terminal, √∫til para depuraci√≥n              | `char *name = ttyname(0);`                                      |
| `ttyslot()`                     | Devuelve el n√∫mero de terminal del proceso actual.                                                      | Rara vez usada, identificaci√≥n del terminal                       | `int slot = ttyslot();`                                         |
| `ioctl(fd, request)`           | Env√≠a comandos de control al dispositivo. Com√∫n para detectar tama√±o del terminal (`TIOCGWINSZ`).       | Saber cu√°ntas columnas tiene la terminal, √∫til para el layout     | `ioctl(1, TIOCGWINSZ, &w);`                                     |

<details>
<summary><strong>üí¨ Entrada/Salida B√°sica</strong></summary>

<br>

| Funci√≥n       | Descripci√≥n                                                                  | Uso com√∫n                            | Uso con c√≥digo                        |
|---------------|------------------------------------------------------------------------------|---------------------------------------|----------------------------------------|
| `printf`      | Imprime texto formateado a la salida est√°ndar.                              | Mensajes de debug o salida del shell | `printf("Hola %s\n", nombre);`        |
| `write`       | Escribe directamente en un descriptor de archivo (stdout, stderr, etc.).    | Imprimir sin usar stdio              | `write(1, "Hola\n", 5);`              |
| `perror`      | Muestra un mensaje de error basado en `errno`.                              | Reportar errores de sistema          | `perror("open");`                     |
| `strerror`    | Devuelve un string que describe un c√≥digo de error.                         | Mostrar mensaje de error personalizado | `char *msg = strerror(errno);`        |

<details>
<summary><strong>üìÅ Manejo de Archivos</strong></summary>

<br>

| Funci√≥n     | Descripci√≥n                                                                 | Uso com√∫n                                     | Uso con c√≥digo                                                   |
|-------------|-----------------------------------------------------------------------------|-----------------------------------------------|------------------------------------------------------------------|
| `access`    | Verifica permisos de acceso a un archivo (`F_OK`, `R_OK`, `W_OK`, `X_OK`).  | Comprobar si un archivo existe o es ejecutable | `if (access("file", F_OK) == 0) {...}`                          |
| `open`      | Abre un archivo y devuelve su descriptor.                                   | Abrir archivos para lectura o escritura        | `int fd = open("file.txt", O_RDONLY);`                          |
| `read`      | Lee datos de un descriptor de archivo.                                      | Leer contenido desde un archivo                | `read(fd, buffer, 100);`                                        |
| `close`     | Cierra un descriptor de archivo.                                             | Liberar recursos tras abrir archivos           | `close(fd);`                                                    |
| `unlink`    | Elimina un archivo del sistema de archivos.                                 | Implementar el comando `rm`                    | `unlink("file.txt");`                                           |
| `stat`      | Obtiene informaci√≥n del archivo (nombre, tama√±o, permisos).                 | Verificar tipo de archivo o permisos           | `stat("archivo", &st);`                                        |
| `lstat`     | Igual que `stat` pero no sigue enlaces simb√≥licos.                          | Verificar si un archivo es un enlace simb√≥lico | `lstat("archivo", &st);`                                       |
| `fstat`     | Igual que `stat` pero usando un descriptor de archivo.                      | Obtener info de un archivo ya abierto          | `fstat(fd, &st);`                                               |


</details> <details> <summary><strong>üë®‚Äçüëß‚Äçüë¶ Gesti√≥n de Procesos</strong></summary>

  | Funci√≥n    | Uso                                                 |
|------------|------------------------------------------------------|
| `fork`     | Crear un nuevo proceso hijo                          |
| `execve`   | Ejecutar un nuevo programa                           |
| `wait`     | Esperar a que termine un hijo                        |
| `waitpid`  | Esperar a un hijo espec√≠fico                         |
| `wait3`    | Igual que `wait`, pero con m√°s info (uso de recursos)|
| `wait4`    | Como `wait3`, pero permite m√°s control               |
| `exit`     | Terminar el proceso actual                           |
| `kill`     | Enviar se√±ales a un proceso                          |

</details> <details> <summary><strong>üîÄ Pipes y Redirecci√≥n</strong></summary>

  | Funci√≥n  | Uso                                        |
|----------|---------------------------------------------|
| `dup`    | Duplicar un descriptor de archivo           |
| `dup2`   | Duplicar y redirigir un descriptor          |
| `pipe`   | Crear un pipe (comunicaci√≥n entre procesos) |

</details> <details> <summary><strong>üß† Se√±ales</strong></summary>

  | Funci√≥n        | Uso                                               |
|----------------|----------------------------------------------------|
| `signal`       | Establecer un manejador de se√±ales                 |
| `sigaction`    | Manejador de se√±ales avanzado                      |
| `sigemptyset`  | Inicializar un conjunto de se√±ales vac√≠o           |
| `sigaddset`    | A√±adir se√±ales a un conjunto                       |


</details> <details> <summary><strong>üåé Variables de Entorno</strong></summary>

  | Funci√≥n  | Uso                                      |
|----------|-------------------------------------------|
| `getenv` | Obtener el valor de una variable de entorno |

</details> <details> <summary><strong>üñ•Ô∏è Control de la Terminal (Termcap)</strong></summary>

  | Funci√≥n     | Uso                                                   |
|-------------|--------------------------------------------------------|
| `tcgetattr` | Obtener atributos de la terminal                       |
| `tcsetattr` | Establecer atributos de la terminal                    |
| `tgetent`   | Cargar la base de datos termcap                        |
| `tgetflag`  | Leer flags del terminal (de termcap)                   |
| `tgetnum`   | Obtener valores num√©ricos del terminal (termcap)       |
| `tgetstr`   | Obtener cadenas del terminal (termcap)                 |
| `tgoto`     | Posicionar el cursor                                   |
| `tputs`     | Imprimir secuencias de control del terminal            |

</details> <details> <summary><strong>üõ†Ô∏è Utilidades de Memoria</strong></summary>

  | Funci√≥n | Uso                                 |
|--------|--------------------------------------|
| `malloc` | Reservar memoria din√°mica          |
| `free`   | Liberar memoria                     |

</details>

üß™ Ejemplo Entrada y Lectura de Comandos

#include <stdio.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <readline/history.h>

int main(void)
{
    char *line;

    while (1)
    {
        line = readline("minishell$ ");
        if (!line)
            break;
        if (*line)
            add_history(line);
        printf("Le√≠do: %s\n", line);
        free(line);
    }
    rl_clear_history();
    return 0;
}

üß™ Ejemplo pr√°ctico: Verificar si un archivo existe y leerlo

#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main(void)
{
    char buffer[101];
    int fd, bytes;

    if (access("readme.txt", F_OK) == 0)
    {
        fd = open("readme.txt", O_RDONLY);
        if (fd == -1)
            return (perror("open"), 1);
        bytes = read(fd, buffer, 100);
        if (bytes > 0)
        {
            buffer[bytes] = '\0';
            write(1, buffer, bytes);
        }
        close(fd);
    }
    else
        write(2, "Archivo no encontrado\n", 23);
    return 0;
}
